tokens SYM_EOF SYM_IDENTIFIER<string> SYM_INTEGER<int> SYM_PLUS SYM_MINUS SYM_ASTERISK SYM_DIV SYM_MOD
tokens SYM_LPARENTHESIS SYM_RPARENTHESIS SYM_LBRACE SYM_RBRACE
tokens SYM_ASSIGN SYM_SEMICOLON SYM_RETURN SYM_IF SYM_WHILE SYM_ELSE SYM_COMMA SYM_PRINT
tokens SYM_EQUALITY SYM_NOTEQ SYM_LT SYM_LEQ SYM_GT SYM_GEQ
non-terminals S INSTR INSTRS LINSTRS ELSE EXPR FACTOR
non-terminals LPARAMS REST_PARAMS
non-terminals BLOC
non-terminals IDENTIFIER INTEGER
non-terminals FUNDEF FUNDEFS
non-terminals ADD_EXPRS ADD_EXPR
non-terminals MUL_EXPRS MUL_EXPR
non-terminals CMP_EXPRS CMP_EXPR
non-terminals EQ_EXPRS EQ_EXPR
axiom S
{

  open Symbols
  open Ast
  open BatPrintf
  open BatBuffer
  open Batteries
  open Utils

  (* TODO *)
  let resolve_associativity term other =
       (* TODO *)
    term


}

rules
S -> FUNDEFS SYM_EOF {  Node (Tlistglobdef, []) }

FUNDEFS -> FUNDEF FUNDEFS
FUNDEFS ->

FUNDEF -> SYM_IDENTIFIER SYM_LPARENTHESIS LPARAMS SYM_RPARENTHESIS INSTR

LPARAMS -> SYM_IDENTIFIER REST_PARAMS
LPARAMS ->

REST_PARAMS -> SYM_COMMA SYM_IDENTIFIER REST_PARAMS
REST_PARAMS ->

INSTR -> SYM_IDENTIFIER SYM_ASSIGN EXPR SYM_SEMICOLON
INSTR -> SYM_IF SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS INSTR ELSE
INSTR -> SYM_WHILE SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS INSTR
INSTR -> SYM_RETURN EXPR SYM_SEMICOLON
INSTR -> SYM_PRINT EXPR SYM_SEMICOLON
INSTR -> BLOC

EXPR -> ADD_EXPR ADD_EXPRS

ADD_EXPR -> MUL_EXPR MUL_EXPRS

MUL_EXPR -> FACTOR

FACTOR -> SYM_INTEGER
FATCOR -> SYM_IDENTIFIER
FACTOR -> SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS

MUL_EXPRS -> SYM_ASTERISK MUL_EXPR MUL_EXPRS
MUl_EXPRS ->

ADD_EXPRS -> SYM_PLUS ADD_EXPR ADD_EXPRS
ADD_EXPRS ->

ELSE -> SYM_ELSE BLOC
ELSE ->

BLOC -> SYM_LBRACE INSTRS SYM_RBRACE

INSTRS -> INSTR INSTRS
INSTRS -> 

